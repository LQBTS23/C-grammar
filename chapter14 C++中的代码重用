14.1 studentc.h
#pragma once
#ifndef  STUDENTC_H_
#define  STUDENTC_H_
#include<iostream>
#include<string>
#include<valarray>
 
class Student
{
private:
	typedef std::valarray<double> ArrayDb;
	std::string name;
	ArrayDb scores;

	std::ostream& arr_out(std::ostream& os) const;
public:
	Student():name("Null Student"),scores(){}
	explicit Student(const std::string & s):name(s),scores(){}
	explicit Student(int n):name("Nully"),scores(n){}
	Student(const std::string& s, int n) :name(s), scores(n) {};
	Student(const std::string & s,const ArrayDb & a):name(s),scores(a){}
	Student(const char * str,const double * pd,int n):name(str),scores(pd,n){}
	~Student(){}
	double Average() const;
	const std::string& Name() const;
	double& operator[](int i);
	double operator[](int i)const;

	friend std::istream& operator>>(std::istream& is, Student& stu);//1 word
	friend std::istream& getline(std::istream& is, Student& stu);//1 line
	friend std::ostream& operator<<(std::ostream& os, const Student& stu);
};
#endif // ! STUDENTC_H_

14.2 student.cpp
  #include "studentc.h"
using namespace std;
using std::string;

double Student::Average() const
{
	if (scores.size() > 0)
		return scores.sum() / scores.size();
	else
		return 0;
}

const string& Student::Name() const
{
	return name;
}

double& Student::operator[](int i)
{
	return scores[i];
}

double Student::operator[](int i) const
{
	return scores[i];
}

ostream& Student::arr_out(ostream& os) const
{
	int i;
	int lim = scores.size();
	if (lim > 0)
	{
		for (i = 0; i < lim; i++)
		{
			os << scores[i] << " ";
			if (i % 5 == 4)
				os << endl;
		}
		if (i % 5 != 0)
			os << endl;
	}
	else
		os << "empty array ";
	return os;
}

istream& operator>>(istream& is, Student& stu)
{
	is >> stu.name;
	return is;
}

istream& getline(istream& is, Student& stu)
{
	getline(is, stu.name);
	return is;
}

ostream& operator<<(ostream& os, const Student& stu)
{
	os << "Scores for " << stu.name << ":\n";
	stu.arr_out(os);
	return os;
}

14.3 use_stuc.cpp
#pragma once
#ifndef STUDENTC_H_
#define STUDENTC_H_
#include<iostream>
#include<string>
#include<valarray>

class Student
{
private:
	typedef std::valarray<double> ArrayDb;
	std::string name;
	ArrayDb scores;
	std::ostream & arr_out(std::ostream & os) const;
public:
	Student() :name("Null Student"),scores(){}
	explicit Student(const std::string & s):name(s),scores(){}
	explicit Student(int n):name("Nully"),scores(n){}
	Student(const std::string & s, int n) :name(s), scores(n) {};
	Student(const std::string & s,const ArrayDb & a):name(s),scores(a){}
	Student(const char * str,const double * pd,int n):name(str),scores(pd,n){}
    ~Student(){}
	double Average()const;
	const std::string & Name() const;
	double & operator[](int i);
	double operator[](int i) const;
	friend std::istream & operator>>(std::istream & is, Student & stu);//1 word
	friend std::istream & getline(std::istream & os, Student & stu);//1 line
	friend std::ostream & operator<<(std::ostream & os, const Student & stu);
};
#endif // !STUDENTC_H_


work0.h
#pragma once
#ifndef WORKER0_H_
#define WORKER0_H_

#include<string>

class Worker
{
private:
	std::string fullname;
	long id;
public:
	Worker():fullname("no one"),id(0L){}
	Worker(const std::string& s, long n):fullname(s),id(n){}
	virtual ~Worker() = 0;
	virtual void Set();
	virtual void Show() const;
};

class Waiter :public Worker
{
private:
	int panache;
public:
	Waiter():Worker(),panache(0){}
	Waiter(const std::string &s,long n,int p=0):Worker(s,n),panache(p){}
	Waiter(const Worker & wk,int p=0):Worker(wk),panache(p){}
	void Set();
	void Show() const;
};
class Singer :public Worker
{
protected:
	enum{other,alto,contralto,soprano,bass,baritone,tenor};
	enum{Vtypes=7};
private:
	static char* pv[Vtypes];
	int voice;
public:
	Singer():Worker(),voice(other){}
	Singer(const std::string & s,long n,int v = other):Worker(s,n),voice(v){}
	Singer(const Worker & wk,int v=other):Worker(wk),voice(v){}
	void Set();
	void Show() const;
};
#endif // !WORKER0_H_

worker0.cpp
#include"Work0.h"
#include<iostream>

using std::cout;
using std::cin;
using std::endl;

Worker::~Worker(){}

void Worker::Set()
{
	cout << "Enter worker's name: ";
	getline(cin, fullname);
	cout << "Enter worker's ID: ";
	cin >> id;
	while (cin.get() != '\n')
		continue;
}

void Worker::Show() const
{
	cout << "Name: " << fullname << "\n";
	cout << "Employee ID: " << id << "\n";
}

void Waiter::Set()
{
	Worker::Set();
	cout << "Enter waiter's panache rating: ";
	cin >> panache;
	while (cin.get() != '\n')
		continue;
}

void Waiter::Show() const
{
	cout << "Categor: waiter\n";
	Worker::Show();
	cout << "Panache rating: " << panache << "\n";
}

char* Singer::pv[] = { "other","alto","contralto","soprano","bass","baritone","tenor" };

void Singer::Set()
{
	Worker::Set();
	cout << "Enter number for singer's vocal range:\n";
	int i;
	for (i = 0; i < Vtypes; i++)
	{
		cout << i << ": " << pv[i] << "    ";
		if (i % 4 == 3)
			cout << endl;
	}
	if (i % 4 != 0)
		cout << endl;
	while (cin >> voice && (voice < 0 || voice >= Vtypes))
		cout << "Please enter a value >= 0 and < " << Vtypes << endl;
	while (cin.get() != '\n')
		continue;
	
}

void Singer::Show() const
{
	cout << "Category:singer\n";
	Worker::Show();
	cout << "Vocal range: " << pv[voice] << endl;
}

worktest.cpp
#include<iostream>
#include"Work0.h"
const int LIM = 4;
int main()
{
	Waiter bob("Bob Apple", 314L, 5);
	Singer bev("Beverly Hills",522L, 3);
	Waiter w_temp;
	Singer s_temp;

	Worker* pw[LIM] = { &bob,&bev,&w_temp,&s_temp };

	int i;
	for (i = 2; i < LIM; i++)
		pw[i]->Set();
	for (i = 0; i < LIM; i++)
	{
		pw[i]->Show();
		std::cout << std::endl;
	}
	return 0;
}


workermi.h
#pragma once
#ifndef WORKERMI_H_
#define WORKERMI_H_

#include<string>

class Worker
{
private:
	std::string fullname;
	long id;
protected:
	virtual void Data() const;
	virtual void Get();
public:
	Worker():fullname("no one"),id(0L){}
	Worker(const std::string& s, long n) :fullname(s),id(n){}
	virtual ~Worker() = 0;
	virtual void Set() = 0;
	virtual void Show() const = 0;
};

class Waiter :virtual public Worker
{
private:
	int panache;
protected:
	void Data() const;
	void Get();
public:
	Waiter():Worker(),panache(0){}
	Waiter(const std::string & s,long n,int p=0):Worker(s,n),panache(p){}
	Waiter(const Worker &wk,int p=0):Worker(wk),panache(p){}
	void Set();
	void Show() const;
};

class Singer :virtual public Worker
{
protected:
	enum { other, alto, contralto, soprano, bass, baritone, tenor };
	enum { Vtypes = 7 };
	void Data() const;
	void Get();
private:
	static char* pv[Vtypes];
	int voice;
public:
	Singer():Worker(),voice(other){}
	Singer(const std::string & s,long n,int v = other):Worker(s,n),voice(v){}
	Singer(const Worker & wk,int v = other):Worker(wk),voice(v){}
	void Set();
	void Show() const;

};

class SingingWaiter :public Singer, public Waiter
{
protected:
	void Data() const;
	void Get();
public:
	SingingWaiter(){}
	SingingWaiter(const std::string& s, long n, int p = 0, int v = other) :Worker(s, n), Waiter(s, n, p), Singer(s, n, v) {};
	SingingWaiter(const Worker & wk,int p = 0,int v = other):Worker(wk),Waiter(wk,p),Singer(wk,v){}
	SingingWaiter(const Waiter & wt,int v = other):Worker(wt),Waiter(wt),Singer(wt,v){}
	SingingWaiter(const Singer & wt,int p=0):Worker(wt),Waiter(wt,p),Singer(wt){}
	void Set();
	void Show() const;
};
#endif // !WORKERMI_H_

workermi.cpp
#include"workermi.h"
#include<iostream>
using std::cout;
using std::cin;
using std::endl;
Worker::~Worker(){}

void Worker::Data() const
{
	cout << "Name: " << fullname << endl;
	cout << "Employee ID: " << id << endl;
}

void Worker::Get()
{
	getline(cin, fullname);
	cout << "Enter worker's ID: ";
	cin >> id;
	while (cin.get() != '\n')
		continue;
}

void Waiter::Set()
{
	cout << "Enter waiter's name: ";
	Worker::Get();
	Get();
}

void Waiter::Show() const
{
	cout << "Category: waiter\n";
	Worker::Data();
	Data();
}

void Waiter::Data() const
{
	cout << "Panache rating: " << panache << endl;
}

void Waiter::Get()
{
	cout << "Enter waiter's panache rating: ";
	cin >> panache;
	while (cin.get() != '\n')
		continue;
}

char* Singer::pv[] = { "other","alto","contralto","soprano","bass","baritone","tenor" };


void Singer::Set()
{
	cout << "Enter singer's name: ";
	Worker::Get();
	Get();
}

void Singer::Show() const
{
	cout << "Category: singer\n";
	Worker::Data();
	Data();
}

void Singer::Data() const
{
	cout << "Vocal range: " << pv[voice] << endl;
}

void Singer::Get()
{
	cout << "Enter number for singer's vocal range:\n";
	int i;
	for (i = 0; i < Vtypes; i++)
	{
		cout << i << ": " << pv[i] << "    ";
		if (i % 4 == 3)
			cout << endl;
	}
	if (i % 4 != 0)
		cout << endl;
	while (cin >> voice && (voice < 0 || voice >= Vtypes))
		cout << "Please enter a value >= 0 and < " << Vtypes << endl;
	while (cin.get() != '\n')
		continue;

}

void SingingWaiter::Data() const
{
	Singer::Data();
	Waiter::Data();
}

void SingingWaiter::Get()
{
	Waiter::Get();
	Singer::Get();
}

void SingingWaiter::Set()
{
	cout << "Enter singing waiter's name: ";
	Worker::Get();
	Get();
}

void SingingWaiter::Show() const
{
	cout << "Category: singing waiter\n";
	Worker::Data();
	Data();
}

workmi.cpp
#include<iostream>
#include<cstring>
#include"workermi.h"

const int SIZE = 5;
int main()
{
	using std::cin;
	using std::cout;
	using std::endl;
	using std::strchr;

	Worker* lolas[SIZE];
	int ct;
	for (ct = 0; ct < SIZE; ct++)
	{
		char choice;
		cout << "Enter ther employee category:\n"
			<< "w: waiter  s:singer   "
			<< "t: singing waiter    q: quit\n";
		cin >> choice;
		while (strchr("wstq", choice) == NULL)
		{
			cout << "Please enter a w, s, t, or q: ";
			cin >> choice;
		}
		if (choice == 'q')
			break;
		switch (choice)
		{
		case 'w': lolas[ct] = new Waiter;
			break;
		case 's': lolas[ct] = new Singer;
			break;
		case 't': lolas[ct] = new SingingWaiter;
			break;
		}
		cin.get();
		lolas[ct]->Set();
	}

	cout << "\nHere is your staff:\n";
	int i;
	for (i = 0; i < ct; i++)
	{
		cout << endl;
		lolas[i]->Show();
	}
	for (i = 0; i < ct; i++)
		delete lolas[i];
	cout << "Bye.\n";
	return 0;
}



